<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Code-Bottle&#39;s Blog</title>
  
  <subtitle>sharing notes</subtitle>
  <link href="https://code-bottle.github.io/atom.xml" rel="self"/>
  
  <link href="https://code-bottle.github.io/"/>
  <updated>2022-09-19T10:51:19.142Z</updated>
  <id>https://code-bottle.github.io/</id>
  
  <author>
    <name>Code-Bottle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello_Git</title>
    <link href="https://code-bottle.github.io/hello-git/"/>
    <id>https://code-bottle.github.io/hello-git/</id>
    <published>2022-09-19T10:38:55.000Z</published>
    <updated>2022-09-19T10:51:19.142Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" alt="img"></p><h3 id="仓库初始化"><a href="#仓库初始化" class="headerlink" title="仓库初始化"></a>仓库初始化</h3><ul><li><strong>创建仓库</strong> ：在工作目录生成.git目录，包含资源元数据，通过git管理操作，创建<strong>默认master分支</strong></li></ul><blockquote><p>git init </p><p>git init newrepo</p></blockquote><ul><li><strong>配置用户信息</strong> ：–global修改用户主目录下.gitconfig，默认所有项目使用的用户信息；去掉–global则修改当前<strong>工作目录</strong>.git&#x2F;config，仅作用于当前项目</li></ul><blockquote><p>git config –global user.name ‘ping’</p><p>git config –global user.email ‘<a href="mailto:&#x70;&#x69;&#110;&#103;&#x40;&#103;&#105;&#x74;&#x2e;&#x63;&#x6f;&#109;">&#x70;&#x69;&#110;&#103;&#x40;&#103;&#105;&#x74;&#x2e;&#x63;&#x6f;&#109;</a>‘</p></blockquote><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ul><li><strong>创建分支</strong>：基于当前分支拷贝创建，不带参数为查看分支，参数-d为删除分支</li></ul><blockquote><p>git branch <branch_name></branch_name></p></blockquote><ul><li><strong>切换分支</strong>：避免切换到不存在的分支，可使用“-b”创建加切换</li></ul><blockquote><p>git checkout master</p><p>git checkout -b <branch_name></branch_name></p></blockquote><ul><li><strong>取回分支</strong>：获取更新的分支代码，对本地开发无影响</li></ul><blockquote><p>git fetch origin master</p></blockquote><ul><li><strong>分支合并</strong>：基于当前分支将其它分支融合进来，对于服务器的master合并工作需要发起<strong>Merge Request</strong>交由管理人员审核</li></ul><blockquote><p>git checkout branch_1</p><p>git merge branch_2</p></blockquote><ul><li><strong>冲突解决</strong>：合并分支出现歧义，通过手动人为编辑解决冲突文件后，需要重新add及commit纳入管理，而底层git也会记忆冲突解决原理，避免后续合并歧义</li></ul><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><ul><li><strong>克隆仓库</strong>：拷贝一个 Git 仓库到本地，包含远程仓库的所有分支</li></ul><blockquote><p>git clone <url> <projectname></projectname></url></p></blockquote><ul><li><strong>远程关联</strong>：项目拷贝<strong>默认关联远程库origin</strong>，关联之后pull和push才能相对应</li></ul><blockquote><p>git remote add origin <server_url></server_url></p><p>git remote -v 显示所有远程仓库</p></blockquote><ul><li><strong>下载代码</strong>：&#x3D;&#x3D;<strong>git pull &#x3D; git fetch + git merge</strong>&#x3D;&#x3D; 获取服务器数据并合并数据进行更新</li></ul><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><ul><li><strong>上传代码</strong>：默认推送到&#x3D;&#x3D;<strong>origin&#x2F;master</strong>&#x3D;&#x3D;</li></ul><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li><strong>添加</strong>：add追踪文件纳入版本控制（添加到<strong>暂存区</strong>index）</li></ul><blockquote><p>git add <filename></filename></p><p>git add . </p></blockquote><ul><li><strong>提交版本</strong>：commit提交内容至<strong>本地仓库</strong>（HEAD指向最后一次提交结果）</li></ul><blockquote><p>git commit -m “代码提交信息”</p></blockquote><p>​“-a”将所有被修改或者已删除的且已经被git管理的文档提交到仓库中,不会造成新文件被提交</p><blockquote><p>git commit -am ‘change info’</p></blockquote><ul><li><strong>查看状态</strong>：”-s”参数获取简单输出，查看文件提交后是否有改动</li></ul><blockquote><p>git status -s</p></blockquote><ul><li><strong>比较差异</strong>：默认比较工作目录和暂存区，输出为目标在源基础上的修改</li></ul><blockquote><p>git diff <source> <target></target></p><p>git diff –cached  查看 index 与 local repositorty 的差别</p><p>git diff HEAD  查看 workspace 和 local repository 的差别</p></blockquote><ul><li><strong>回退版本</strong>：可以指定退回某一次提交的版本，HEAD表示当前版本，HEAD^个数i表示前i个版本，HEAD~i表示前i个版本</li></ul><blockquote><p>git reset [–soft | –mixed |–hard] [HEAD]</p><p>git reset HEAD <file> 取消已缓存的内容，不会进行改动提交</file></p></blockquote><ul><li><strong>查看日志</strong>：查看历史提交记录，参数–oneline显示简洁版本，–graph查看拓扑图，–reverse逆向输出，–author指定用户</li></ul><blockquote><p>git log</p></blockquote><ul><li><strong>标签</strong>：发布版本的快照，标签比提交号方便，分轻量级的和含注解（参数-a）的标签</li></ul><blockquote><p>git tag -a v1.0 <commit_id></commit_id></p></blockquote><h3 id="Upstream及分支理解"><a href="#Upstream及分支理解" class="headerlink" title="Upstream及分支理解"></a>Upstream及分支理解</h3><ul><li>upstream可以理解为分支间的通道，用于连接本地分支和远程分支，保证数据推送流通正确性</li></ul><blockquote><p>git branch –set-upstream–to&#x3D;origin&#x2F;remote_branch local_branch</p><p>git push -u origin branch 推送分支到服务器同时关联本地分支</p></blockquote><ul><li>分支类型有三类：本地分支feature(L)，远程分支feature(R)，指向远程分支的指针，以remotes开头即远程分支在本地的镜像feature(T)。</li><li>其实feature(L)和feature(R)从技术实现上根本没有任何交集，它们之间的关联全是通过feature(T)这个桥梁实现的。</li><li>其实在feature(L)上执行了git fetch命令后，Git会把feature(R)上的改动下载到本地更新到feature(T)分支上，如果此后不执行git merge的话，那么你的feature(L)和feature(T)就会存在差异，只有执行了git merge命令后才会把feature(T)中的内容合并到feature(L)中。</li><li>在simple模式下，我们feature(L)分支的upstream其实指向的就是feature(T)，而feature(T)这个指针就会指向真正的远程分支feature(R)。所以如果我们的feature(L)有了改动，执行git push的话，Git会先把改动更新到feature(T)中，然后再讲feature(T)的改动推向远程的feature(R)中。</li></ul><h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><ul><li>比如你是在worker1(L)分支上的开发者，做完了一天的工作，先不要提Merge Request，而是先checkout到master(L)上，pull一下，把服务器上master的代码拉下来，使本地的master(L)是最新的master代码，然后checkout回worker1(L)分支，将master(L)分支merge到worker1(L)上，这时候就有可能发生冲突了，因为可能在你下班之前，worker2分支的同事已经提交了代码并且更新了master，而你们恰巧修改了同一个文件。这时候冲突了不要紧，因为冲突是发生在你本地的，你只要在本地把冲突解决了，然后push到worker1分支上去，再提Merge Request，就不会使服务器上的master产生代码冲突了。当你早上来上班时，尽量也checkout到master(L)，pull一下，再checkout回worker1(L)，把master(L)分支的内容merge过来，完成之后再进行开发。这样就是尽量保持在昨晚之后的最新的代码上进行开发，以减少产生冲突的可能性。</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><p><a href="https://www.runoob.com/git/git-tutorial.html">菜鸟教程Git</a></p></li><li><p><a href="https://blog.csdn.net/qq_37772475/article/details/107140061">Git介绍</a></p></li><li><p><a href="https://blog.csdn.net/dongapple/article/details/80451249">Git远程操作详解</a></p></li></ul>]]></content>
    
    
    <summary type="html">Git 是一个开源的分布式版本控制系统，利用空间换时间，对文件版本记录快照，高效和快速恢复。使用git管理的项目，有工作区，暂存区，本地仓库，远程仓库四个区域，文件还有修改，暂存，提交三个状</summary>
    
    
    
    <category term="教程" scheme="https://code-bottle.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Git" scheme="https://code-bottle.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷功能</title>
    <link href="https://code-bottle.github.io/idea-keymap/"/>
    <id>https://code-bottle.github.io/idea-keymap/</id>
    <published>2022-09-07T04:12:56.000Z</published>
    <updated>2022-09-08T09:35:47.735Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl + D</td><td align="center">复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面</td></tr><tr><td align="center">Ctrl + C</td><td align="center">复制光标所在行 或 复制选择内容</td></tr><tr><td align="center">Ctrl + V</td><td align="center">粘贴由复制或剪切所选择的内容</td></tr><tr><td align="center">Ctrl + X</td><td align="center">剪切光标所在行 或 剪切选择内容</td></tr><tr><td align="center">Ctrl + Y</td><td align="center">删除光标所在行 或 删除选中的行</td></tr><tr><td align="center">Ctrl + Z</td><td align="center">撤销</td></tr><tr><td align="center">Ctrl + F</td><td align="center">在当前文件进行文本查找</td></tr><tr><td align="center">Ctrl + R</td><td align="center">在当前文件进行文本替换</td></tr><tr><td align="center">Ctrl + W</td><td align="center">递进式选择代码块</td></tr><tr><td align="center">Ctrl + B</td><td align="center">进入光标所在的方法&#x2F;变量的接口，等效于 Ctrl + 左键单击</td></tr><tr><td align="center">Ctrl + &#x2F;</td><td align="center">注释光标所在行代码</td></tr><tr><td align="center">Ctrl + Space</td><td align="center">基础代码补全</td></tr></tbody></table><h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Alt + Enter</td><td align="center">提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td align="center">Alt+&#x2F;</td><td align="center">快速补全代码</td></tr></tbody></table><h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Shift + Enter</td><td align="center">在当前行下面生成一行空行，光标自动移到空行行首</td></tr><tr><td align="center">Shift + F9</td><td align="center">等效于点击工具栏的 <code>Debug</code> 按钮</td></tr><tr><td align="center">Shift + F10</td><td align="center">等效于点击工具栏的 <code>Run</code> 按钮</td></tr></tbody></table><h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl+Alt"></a>Ctrl+Alt</h3><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl + Alt + L</td><td align="center">格式化代码，可以对当前文件和整个包目录使用</td></tr><tr><td align="center">Ctrl + Alt + O</td><td align="center">优化导入的类，可以对当前文件和整个包目录使用</td></tr><tr><td align="center">Ctrl + Alt + T</td><td align="center">对选中的代码弹出环绕选项if,while,try&#x2F;catch</td></tr></tbody></table><h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl+Shift"></a>Ctrl+Shift</h3><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl + Shift + Delete</td><td align="center">去除相关的代码块包装</td></tr><tr><td align="center">Ctrl + Shift + F</td><td align="center">根据输入内容查找整个项目 或 指定目录内文件</td></tr><tr><td align="center">Ctrl + Shift + R</td><td align="center">根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件</td></tr><tr><td align="center">Ctrl + Shift + W</td><td align="center">递进式取消选择代码块</td></tr><tr><td align="center">Ctrl + Shift + &#x2F;</td><td align="center">代码块注释</td></tr><tr><td align="center">Ctrl + Shift + Enter</td><td align="center">自动结束代码，行末自动添加分号</td></tr></tbody></table><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">.var</td><td align="center">自动分配变量名，在新建对象时在后面加<code>.var</code></td></tr><tr><td align="center">double shfit</td><td align="center">全局搜索</td></tr><tr><td align="center">Home&#x2F;End</td><td align="center">快速定位行首和行尾</td></tr><tr><td align="center">.（常用null,not,return…）</td><td align="center">快速判断返回等</td></tr></tbody></table><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><p>代码模板位于IDEA中Settings–&gt;Editor–&gt;Live Templates &#x2F;Postfix Completions</p><table><thead><tr><th align="center">模板</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">psvm</td><td align="center">快速生成主函数main</td></tr><tr><td align="center">sout&#x2F;soutp&#x2F;soutm&#x2F;soutv</td><td align="center">快速生成打印语句&#x2F;参数&#x2F;方法&#x2F;变量</td></tr><tr><td align="center">fori&#x2F;itar ，iter</td><td align="center">快速生成普通&#x2F;增强for 循环</td></tr><tr><td align="center">list.fori&#x2F;for</td><td align="center">快速生成集合的普通&#x2F;增强for循环</td></tr><tr><td align="center">psf&#x2F;prsf</td><td align="center">快速生成共有&#x2F;私有静态常量</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">IDEA快捷键设置方式，打开Settings--&gt;keymap即可，可选择功能搜索与快捷键搜索两种方式，下面记录常用的快捷键。</summary>
    
    
    
    <category term="教程" scheme="https://code-bottle.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="IDEA" scheme="https://code-bottle.github.io/tags/IDEA/"/>
    
    <category term="keymap" scheme="https://code-bottle.github.io/tags/keymap/"/>
    
  </entry>
  
  <entry>
    <title>Java入门</title>
    <link href="https://code-bottle.github.io/java-introduction/"/>
    <id>https://code-bottle.github.io/java-introduction/</id>
    <published>2022-09-07T02:33:15.000Z</published>
    <updated>2022-09-19T03:49:15.354Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><code>注意：以下总结基于JDK1.8版本</code></p><p>JDK：Java Development Kit，Java开发工具包，包含JRE</p><p>JRE：Java Runtime Environment，Java运行时环境，包含JVM</p><p>JVM：Java Virtual Machine，Java虚拟机</p><p>JDK&#x3D;JRE+开发工具(源码编译：javac命令)</p><p>JRE&#x3D;JVM+核心类库(解释运行：java命令)</p><h3 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h3><ul><li><p>程序基础</p><ol><li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。</p><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。</p><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p></li><li><p><strong>基本语法</strong>：标识符以字母，$或_开始，大小写敏感，类名首字母大写，方法名小写字母开头，后续单词大写，源文件名与类名相同，主方法入口为psvm。</p><p>Java有3种注释，单行注释，以<code>//</code>开头，直到这一行的结尾结束；多行注释以<code>/*</code>星号开头，以<code>*/</code>结束，可以有多行；或者以<code>/**</code>开头，以<code>*/</code>结束，如果有多行，每行通常以星号开头。</p></li><li><p><strong>关键字</strong></p><ul><li><p><strong>48个关键字</strong>：abstract、assert、boolean、break、byte、case、catch、char、class、continue、default、do、double、else、enum、extends、final、finally、float、for、if、implements、import、int、interface、instanceof、long、native、new、package、private、protected、public、return、short、static、strictfp、super、switch、synchronized、this、throw、throws、transient、try、void、volatile、while。</p></li><li><p>2个保留字：goto、const。</p></li><li><p>3个特殊直接量：true、false、null。</p></li></ul></li></ol></li><li><p>数据类型</p><ol><li><p><strong>八大基本数据类型</strong>（二进制补码表示，整数默认int，浮点数默认double）</p><ul><li><p>整数类型：byte（1B），short（2B），int（4B），long（8B）</p></li><li><p>浮点数类型：float（4B），double（8B）</p></li><li><p>字符类型：char（0&#x2F;1）</p></li><li><p>布尔类型：boolean（16 位 Unicode 字符）</p></li><li><p>自动类型转换：byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</p></li></ul></li><li><p>引用数据类型：诸如对象，数组，字符串等</p></li></ol></li><li><p>变量类型</p><ul><li>类变量&#x2F;静态变量：独立于方法之外的变量，用 static 修饰，一份拷贝，初始化后不可改变</li><li>实例变量：独立于方法之外的变量，没有 static 修饰，具有默认值，常用private</li><li>局部变量：类的方法中的变量，需要初始化，作用域为方法</li></ul></li><li><p>修饰符</p><ol><li><p><strong>访问修饰符</strong>：private(方法) –&gt; default(包) –&gt; protected(同包子类) –&gt; public(所有类)</p></li><li><p><strong>非访问修饰符</strong>：</p><p>static 修饰符，用来修饰静态类方法和类变量，一般通过类名调用，所有实例共享</p><p>final 修饰符，<strong>修饰类不能够被继承，修饰方法不能被继承类重写</strong>，修饰变量为不可修改的常量</p><p>abstract 修饰符，用来创建抽象类和抽象方法。</p><p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p></li></ol></li><li><p>运算符：算术运算符,关系运算符,位运算符,逻辑运算符,赋值运算符,三目运算符<code>?:</code>,instanceof运算符(判断实例是否为指定类型或子类)</p></li><li><p>流程控制</p><ol><li><p><strong>顺序结构</strong>：<code>;</code>结尾</p></li><li><p><strong>条件结构</strong>：if…else &#x2F; switch…case</p></li><li><p><strong>循环结构</strong>：while，do…while，for</p><p>注意：break跳出当前循环代码块，continue跳转下一次循环迭代</p></li></ol></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>声明创建<ul><li>dataType[] arrayRefVar &#x3D; new dataType[arraySize];</li><li>dataType[] arrayRefVar &#x3D; {value0, value1, …, valuek};</li><li>多维数组可直接多维分配空间，也可先高维分配，后低维分配</li></ul></li><li>遍历<ul><li>普通for循环按索引（从0开始）遍历</li><li>增强for循环直接遍历元素</li></ul></li><li>排序<ul><li>Arrays数组类提供sort()方法进行排序</li></ul></li></ul><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li><p>方法</p><p>方法&#x3D;&#x3D;&gt;方法头（修饰符，返回值，方法名，形参）+ 方法体</p><p>构造方法：</p><ul><li>默认的无参数构造方法；</li><li>编译器根据参数自动判断选择哪个构造方法；</li><li>构造方法相互调用，便于代码复用。</li></ul><p>参数绑定：</p><ul><li>基本类型参数的传递，是调用值的复制。</li><li>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方。</li></ul></li><li><p>重载 <strong>overload</strong></p><ul><li>同名方法，形参列表不同，方法签名不同</li><li>一般返回值是相同的</li></ul></li><li><p><strong>封装 Encapsulation</strong></p><p>封装实现细节，对外提供接口（this.set+get），便于修改，减少耦合</p></li><li><p><strong>继承 Extends</strong></p><ul><li>单继承+多重继承，根类为object，父类通用，子类具体</li><li>子类访问父类protected变量和方法，重写<strong>override</strong>，返回值和形参不变，修改核心</li><li>子类不会继承任何父类的构造方法，子类显式调用<code>super()</code>并给出参数以定位到父类相应的构造方法</li><li>继承是is-a关系，组合是has-a关系</li><li>可以安全地向上转型为更抽象的类型；借助<code>instanceof</code>判断也可以强制向下转型</li></ul></li><li><p><strong>多态</strong></p><ul><li><p>针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法</p></li><li><p>存在的必要条件&#x3D;继承+重写+父类引用指向子类对象</p></li><li><p>实现方式：重写，接口，抽象类和抽象方法</p></li><li><p>object类定义的三个重要方法</p><ul><li><p>toString()：把instance输出为String；</p></li><li><p><strong>equals 的作用:</strong><br> 　　引用类型：默认情况下，比较的是地址值，引用类型的比较一般都会覆写该方法</p></li></ul><p>  <strong>&#x3D;&#x3D; 的作用：</strong><br>  　　基本类型：比较的就是值是否相同<br>  　　引用类型：比较的就是地址值是否相同</p><ul><li>hashCode()：计算一个instance的哈希值。</li></ul></li></ul></li><li><p>接口 <strong>Implements</strong></p><ul><li>接口比抽象类更加抽象，支持多继承</li><li>接口中的成员变量只能是默认public static final</li><li>接口都是抽象方法，默认public abstract省略，但可以定义default方法</li><li>接口可以继承接口，扩展功能</li><li><strong>函数式接口：只能有一个抽象方法的接口，比如Comparator、Runnable、Callable</strong></li></ul></li><li><p>抽象类和抽象方法 <strong>abstract</strong></p><ul><li>抽象类不能实例化对象，设计原则用于子类继承，非抽象子类必须实现父类的抽象方法</li><li>抽象方法只定义方法签名（只有方法名加括号），含有抽象方法必须申明为抽象类</li></ul></li></ul><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><ul><li><p><strong>String</strong></p><ul><li><p>可以直接创建（存储在公共池中），也可以new创建（新建对象在堆上）</p></li><li><p>常用操作：</p><ul><li>长度lenth()，拼接concat()或+</li><li>索引查找indexOf()，子串查看contains()</li><li>提取子串substring()，替换子串replace()</li><li>格式化字符串String.format()，占位符：整数<code>%s</code>字符串<code>%s</code>浮点数<code>%f</code></li><li>类型转换：String.valueOf()，Integer.parseInt()，toCharArray()</li></ul></li><li><p>字符编码：ASCII（1B）&#x3D;&gt; GB2312（1B）&#x3D;&gt; Unicode（2B+）&#x3D;&gt; UTF-8（1-4B）</p><p>java使用unicode编码表示String 和char，转换编码就是String和byte()转换（优先考虑UTF-8）</p></li><li><p>String 是不可变对象，操作不改变原对象，二是返回新的字符串</p></li><li><p>StringBuffer和<strong>StringBuilder</strong>（可变对象，链式操作自身）</p></li></ul></li><li><p>Math</p><ul><li>数学计算库：min&#x2F;max，abs，pow&#x2F;sqrt，exp&#x2F;log ……</li></ul></li><li><p>Random</p><ul><li>SecureRandom：生成安全的随机数</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(seed);</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> r.nextInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li><p>大数：BigInteger和BigDecimal</p></li><li><p>枚举</p><ul><li>枚举是特殊的类，为了做信息的标识和分类，声明一组带标识符的常数</li><li>name()获取枚举常量的名字，ordinal()获取常量定义的顺序</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED,GREEN,BLUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Color</span> <span class="variable">c</span> <span class="operator">=</span> Color.RED; <span class="comment">// 不能new实例，实际上枚举实例都是唯一</span></span><br></pre></td></tr></table></figure><ul><li><p>日期时间</p><ul><li>Date和Calendar（旧API）; 格式化SimpleDateFormat</li><li>yyyy：年、MM：月、dd: 日、HH: 小时、mm: 分钟、ss: 秒</li><li>LocalDateTime（新API）；格式化DateTimeFormatter</li></ul></li><li><p><strong>Lambda表达式</strong></p><ul><li>可选类型声明、可选括号、可选返回关键字</li><li>形如：参数列表 -&gt; 方法体</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MathOperation</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="title function_">operation</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MathOperation</span> <span class="variable">add</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">add.operation(<span class="number">2</span>, <span class="number">6</span>); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>​处理函数式接口时，可把实例化匿名内部类改写为Lambda表达式，简化代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Arrays.sort(array, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">Arrays.sort(array, (s1, s2) -&gt; s1.compareTo(s2));</span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><ul><li>Error表示严重错误，无法处理；而Exception是运行时错误，可以被捕获并处理。不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类不做强制性捕获要求，剩下必须捕获的又称为检查性异常</li></ul><p><img src="/java-introduction/error.png" alt="error"></p><ul><li>采用try…catch…finally捕获异常；调用<code>printStackTrace()</code>可以打印异常的传播栈</li><li>只要是方法声明的Checked Exception，就需要在调用层捕获或者抛出</li><li>日志库取代手动打印<ul><li>java.util.logging</li><li>Apache第三方日志库Commons Logging，自动搜索挂接Log4j</li></ul></li></ul><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><p>Java标准库自带的<code>java.util</code>包提供了集合类：<code>Collection</code>，它是除<code>Map</code>外所有其他集合类的根接口。优点有：接口和实现分离，支持泛型，通过迭代器统<strong>Iterator</strong>一访问集合。</p><ul><li><p><strong>List</strong></p><ul><li>有序列表：数组实现ArrayList和链表实现LinkedList</li><li>其它操作：add、get、set、remove、size</li><li>在List中查找元素时，List的实现类通过元素的equals()方法比较两个元素是否相等，因此，放入的元素必须正确<strong>重写equals()方法</strong>。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三种常用遍历方式</span></span><br><span class="line"><span class="keyword">for</span>(T t : list)&#123;</span><br><span class="line">    System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Iterator&lt;String&gt; it = list.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Map</strong></p><ul><li>键值映射表，通过key高效查找value，Map查找速度比List快，可作为缓存</li><li>key无序HashMap，有序TreeMap</li><li>其它操作：put(key,value)、get(key)、size()、containsKey(key)、getOrDefault(key,value)</li><li>map采用空间换时间的方式，key通过hashCode()计算数组索引，返回对应value<ul><li>作为key的对象必须正确<strong>重写equals()方法</strong></li><li>作为key的对象还必须正确<strong>重写hashCode()方法</strong>，并且保证相等对象哈希值相等（保证正确性），不相等对象哈希值尽量不相等（减少冲突）</li></ul></li><li>hashmap内部使用数组默认大小为16，自动扩容*2，但需要重现计算索引，避免影响性能，一般提前预设定好大小</li><li>哈希冲突：利用list存储不同key但hashcode相同的value</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;K,V&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;K,V&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历key</span></span><br><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历key-value</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, <span class="type">int</span>&gt; entry : map.entrySet())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>Set</strong></p><ul><li>不重复的元素集合，相当于只有不重复的key</li><li>无序HashSet，有序TreeSet</li><li>其它操作：add、remove、contains、size</li><li>放入Set的元素和Map的key类似，要正确<strong>重写equals()和hashCode()方法</strong>，否则元素无法正确加入Set</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;T&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;T&gt;();</span><br></pre></td></tr></table></figure><ul><li>Collections.sort()<ul><li>第一个参数为集合实例，第二个参数为比较器Comparator（利用匿名内部类或Lambda表达式实现）</li><li>重写compare方法注意，升序和降序区分：返回-1代表前者放前面，即权重小的放前面</li></ul></li></ul><h3 id="反射-Reflection"><a href="#反射-Reflection" class="headerlink" title="反射 Reflection"></a>反射 Reflection</h3><ul><li>反射机制用于在程序运行期间动态变化时，对任意类或对象都能调用其字段和方法（通过Class实例获取）</li><li>class在JVM中动态加载，JVM为每一个class创建一个Class类型的实例（名为Class的class），而Class实例包含了该class的所有信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> String.class; <span class="comment">// 静态变量获取实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (String) c.newInstance(); <span class="comment">//通过Class实例new出对应类型实例</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> s.getClass(); <span class="comment">// 实例变量的getClass()方法</span></span><br><span class="line"></span><br><span class="line"><span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>); <span class="comment">//传入完整类名，利用静态方法获取</span></span><br></pre></td></tr></table></figure><ul><li><p>反射访问字段：<code>Class实例</code>通过getField(name)、getDeclaredField(name)方法获取<code>Field实例</code>，利用Field可以获取字段信息，读取或者设置对象字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段，会破坏封装</p></li><li><p>反射调用方法：<code>Class实例</code>通过getMethod(name, Class)、getDeclaredMethod(name, Class)方法获取<code>Method实例</code>，利用Method可以获取方法信息，采用<strong>invoke</strong>(instance, parameters)调用对象的某个方法</p></li><li><p>反射调用构造方法：通过<code>Class</code>实例的方法可以获取<code>Constructor</code>实例，通过<code>Constructor</code>实例可以创建一个实例对象</p></li><li><p>反射获取继承关系：getSuperclass获取父类类型，getInterfaces获取当前类实现的所有接口</p></li><li><p><strong>动态代理</strong>：动态代理不需要在编译期就实现，并且往往可以代理多个类class，拦截对真实业务对象的访问。静态代理只代理一个类class，由程序员编写，在编译器就生成相应的.class文件，由程序员调用。</p><ul><li><p>使用代理模式必须要让代理类和目标类实现相同的接口，客户端通过代理类来调用目标方法，代理类会将所有的方法调用，分派到目标对象上反射执行</p></li><li><p>动态代理是通过Proxy类创建代理对象，然后将接口方法代理给InvocationHandler接口完成的</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实现接口的方法调用（匿名内部类）</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * proxy:代表动态代理对象</span></span><br><span class="line"><span class="comment">             * method：代表正在执行的方法</span></span><br><span class="line"><span class="comment">             * args：代表调用目标方法时传入的实参</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;morning&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Good morning, &quot;</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 通过Proxy创建代理对象</span></span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入接口类ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; Hello.class &#125;, <span class="comment">// 传入要实现的接口数组</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 代理对象调用方法：调用handler的invoke方法(反射调用被代理对象的方法)</span></span><br><span class="line">        hello.morning(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">morning</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解-Annotation"><a href="#注解-Annotation" class="headerlink" title="注解 Annotation"></a>注解 Annotation</h3><ul><li>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：用作标注的元数据</li><li>自定义注解<ul><li>使用@interface定义注解</li><li>添加参数以及default默认值，最常用参数为value</li><li>使用元注解配置注解，Target指定应用范围，Retention指定生命周期</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">type</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">    String <span class="title function_">level</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;info&quot;</span>;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注解按生命周期分有三类</p><ul><li>SOURCE：在编译期被丢弃，如@Override、@SuppressWarnings</li><li>CLASS：仅保存在class文件中，加载结束后并不会存在于内存中</li><li>RUNTIME：加载进JVM，并且在运行期可以被程序读取</li></ul></li><li><p>使用反射API读取注解信息</p></li><li><p>添加自定义注解本身对程序逻辑没有任何影响，需要编写代码来使用注解，比如检查字段规则</p></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3>]]></content>
    
    
    <summary type="html">Java是基于JVM虚拟机的跨平台语言，介于编译型语言和解释型语言之间，实现了“一次编写，到处运行”的效果。Java可分为Java ME --&gt; Java SE --&gt;Java EE三个体系。Java特点包括简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等。</summary>
    
    
    
    <category term="学习路线" scheme="https://code-bottle.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    <category term="Java" scheme="https://code-bottle.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/Java/"/>
    
    
    <category term="Java" scheme="https://code-bottle.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>编程从入门到入土</title>
    <link href="https://code-bottle.github.io/code-map/"/>
    <id>https://code-bottle.github.io/code-map/</id>
    <published>2022-09-06T09:27:30.000Z</published>
    <updated>2022-09-08T09:37:53.731Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="1、Java核心基础"><a href="#1、Java核心基础" class="headerlink" title="1、Java核心基础"></a>1、Java核心基础</h3><ul><li><p>Java基础</p><ul><li><input disabled type="checkbox"> 语法</li><li><input disabled type="checkbox"> 数组</li><li><input disabled type="checkbox"> 异常处理</li><li><input disabled type="checkbox"> 常用类</li></ul></li><li><p>面向对象</p><ul><li><input disabled type="checkbox"> 封装</li><li><input disabled type="checkbox"> 继承</li><li><input disabled type="checkbox"> 多态</li></ul></li><li><p>Java高级</p><ul><li><input disabled type="checkbox"> 多线程</li><li><input disabled type="checkbox"> 集合</li><li><input disabled type="checkbox"> IO流</li><li><input disabled type="checkbox"> 注解</li><li><input disabled type="checkbox"> 泛型</li><li><input disabled type="checkbox"> 反射</li></ul></li></ul><h3 id="2、Java企业级开发"><a href="#2、Java企业级开发" class="headerlink" title="2、Java企业级开发"></a>2、Java企业级开发</h3>]]></content>
    
    
    <summary type="html">学习路线一条龙</summary>
    
    
    
    <category term="学习路线" scheme="https://code-bottle.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
    
    <category term="TODO" scheme="https://code-bottle.github.io/tags/TODO/"/>
    
  </entry>
  
  <entry>
    <title>Hello_Hexo</title>
    <link href="https://code-bottle.github.io/hello-hexo/"/>
    <id>https://code-bottle.github.io/hello-hexo/</id>
    <published>2022-09-02T14:53:43.000Z</published>
    <updated>2022-09-08T09:36:58.369Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>详情可访问<a href="https://hexo.io/docs/">Hexo官方文档</a></p><h3 id="Hexo命令"><a href="#Hexo命令" class="headerlink" title="Hexo命令"></a>Hexo命令</h3><ul><li>初始化博客</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><ul><li>新建页面</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;my_page&quot;</span></span><br></pre></td></tr></table></figure><ul><li>新建文章</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;my_blog&quot;</span></span><br></pre></td></tr></table></figure><ul><li>启动服务，本地预览博客</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><ul><li>生成静态网页文件(位于public文件夹)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><ul><li>清空缓存即public文件夹</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><ul><li>部署网站到服务器</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>站点配置文件：根目录下_config,yml</li><li>主题配置文件：主题目录下_config.yml</li><li>NexT主题配置，详见<a href="http://theme-next.iissnan.com/">NexT使用文档</a></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.laijiahao.cn/posts/a1047ed6/">搭建hexo博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/26625249/">GitHub+Hexo 搭建个人网站详细教程</a></li><li><a href="https://notes.iissnan.com/">IIssNan’s Notes</a></li></ul>]]></content>
    
    
    <summary type="html">Hexo是一款基于Node.js，利用Markdown编写文章生成静态网站的框架。在此记录一些Hexo常见操作和命令。</summary>
    
    
    
    <category term="教程" scheme="https://code-bottle.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Hexo" scheme="https://code-bottle.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>demo</title>
    <link href="https://code-bottle.github.io/demo/"/>
    <id>https://code-bottle.github.io/demo/</id>
    <published>2022-09-02T03:29:22.000Z</published>
    <updated>2022-09-08T09:37:21.268Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/demo/dog.png" alt="dog"></p><span id="more"></span><div class="tabs" id="dog"><ul class="nav-tabs"><li class="tab active"><a href="#dog-1">A</a></li><li class="tab"><a href="#dog-2">B</a></li><li class="tab"><a href="#dog-3">C</a></li></ul><div class="tab-content"><div class="tab-pane active" id="dog-1"><p><strong>选项卡 1</strong> </p></div><div class="tab-pane" id="dog-2"><p><strong>选项卡 2</strong></p></div><div class="tab-pane" id="dog-3"><p><strong>选项卡 3</strong> </p></div></div></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/demo/dog.png&quot; alt=&quot;dog&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Test" scheme="https://code-bottle.github.io/tags/Test/"/>
    
  </entry>
  
</feed>
